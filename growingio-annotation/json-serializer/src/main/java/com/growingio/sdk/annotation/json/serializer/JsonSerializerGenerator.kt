/*
 * Copyright (C) 2023 Beijing Yishu Technology Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.growingio.sdk.annotation.json.serializer

import androidx.annotation.FloatRange
import androidx.annotation.IntRange
import androidx.annotation.Nullable
import com.growingio.sdk.annotation.json.JsonAlias
import com.growingio.sdk.annotation.json.JsonIgnore
import com.growingio.sdk.annotation.json.JsonSerializer
import com.growingio.sdk.annotation.json.serializer.ProcessUtils.Companion.FIELD_REPLACE_REG
import com.growingio.sdk.annotation.json.serializer.ProcessUtils.Companion.GENERATE_CLASS_APPEND
import com.growingio.sdk.annotation.json.serializer.ProcessUtils.Companion.JSON_OBJECT_CLASS
import com.growingio.sdk.annotation.json.serializer.ProcessUtils.Companion.JSON_OBJECT_EXCEPTION
import com.growingio.sdk.annotation.json.serializer.ProcessUtils.Companion.JSON_OBJECT_PACKAGE
import com.growingio.sdk.annotation.json.serializer.ProcessUtils.Companion.JSON_SERIALIZABLE_CLASS
import com.growingio.sdk.annotation.json.serializer.ProcessUtils.Companion.JSON_SERIALIZABLE_PACKAGE
import com.growingio.sdk.annotation.json.serializer.ProcessUtils.Companion.TEXT_UTILS_CLASS
import com.growingio.sdk.annotation.json.serializer.ProcessUtils.Companion.TEXT_UTILS_PACKAGE
import com.squareup.javapoet.ClassName
import com.squareup.javapoet.FieldSpec
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.ParameterizedTypeName
import com.squareup.javapoet.TypeName
import com.squareup.javapoet.TypeSpec
import java.lang.Exception
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.element.Element
import javax.lang.model.element.Modifier
import javax.lang.model.element.TypeElement
import javax.lang.model.element.VariableElement
import javax.lang.model.type.TypeKind

/**
 *
 * <p> The output file generated by this class with a JsonSerializer.
 *
 * @author cpacm 7/13/23
 */
internal class JsonSerializerGenerator(
    private val processEnv: ProcessingEnvironment,
    private val processUtils: ProcessUtils,
) {
    fun generate(jsonSerializer: TypeElement, containSuperElement: Boolean) {
        val annotation: JsonSerializer = jsonSerializer.getAnnotation(
            JsonSerializer::class.java,
        )

        val builderName: String = annotation.builder
        val fields: MutableList<VariableElement> = mutableListOf()
        val allElements: List<Element> = jsonSerializer.enclosedElements
        for (e in allElements) {
            if (e is VariableElement && !e.modifiers.contains(Modifier.STATIC)) {
                val jsonIgnoreAnnotation = e.getAnnotation(JsonIgnore::class.java)
                if (jsonIgnoreAnnotation == null) {
                    fields.add(e)
                }
            }
        }

        val generatedCodePackageName = jsonSerializer.enclosingElement.toString()
        val generatedName = jsonSerializer.simpleName.toString() + GENERATE_CLASS_APPEND
        val generateClass = ClassName.get(generatedCodePackageName, generatedName)
        processUtils.debugLog(generateClass.toString())

        val eventType =
            processEnv.elementUtils.getTypeElement(jsonSerializer.qualifiedName.toString())
        val eventBuilderType =
            processEnv.elementUtils.getTypeElement(jsonSerializer.qualifiedName.toString() + "." + builderName)

        val builderType = ClassName.get(eventBuilderType)

        val superinterface = ParameterizedTypeName.get(
            ClassName.get(JSON_SERIALIZABLE_PACKAGE, JSON_SERIALIZABLE_CLASS), // rawType
            ClassName.get(eventType), // the value for T
            builderType, // the value for R
        )

        val jonSerialBuilder = TypeSpec.classBuilder(generateClass).addJavadoc(
            """
                            <p>This class is generated and should not be modified
                            
            """.trimIndent(),
        ).addModifiers(Modifier.PUBLIC, Modifier.FINAL).addSuperinterface(superinterface)
            .addField(generateInstanceField(generateClass))
            .addMethod(generateStaticCreateMethod(generateClass, generatedName))
            .addMethod(
                generateToJsonMethod(
                    ClassName.get(eventType),
                    fields,
                    jsonSerializer,
                    containSuperElement,
                ),
            )
            .addMethod(
                generateParseFromMethod(
                    builderType,
                    builderName,
                    fields,
                    jsonSerializer,
                    containSuperElement,
                ),
            )

        processUtils.writeClass(generatedCodePackageName, jonSerialBuilder.build())
    }

    /**
     * private static volatile BaseEventJsonSerializableFactory instance;
     */
    private fun generateInstanceField(instance: TypeName): FieldSpec {
        return FieldSpec.builder(instance, "instance")
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.VOLATILE).build()
    }

    /**
     * public static BaseEventJsonSerializableFactory create() {
     *    if (instance == null) {
     *       instance = new BaseEventJsonSerializableFactory();
     *    }
     *    return instance;
     * }
     */
    private fun generateStaticCreateMethod(instance: TypeName, generatedName: String): MethodSpec {
        return MethodSpec.methodBuilder("create").addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .beginControlFlow("if (instance == null)")
            .addStatement("instance = new $generatedName()")
            .endControlFlow()
            .returns(instance).addStatement("return instance").build()
    }

    /**
     * @Override
     * public void toJson(JSONObject jsonObject, BaseEvent event) {}
     */
    private fun generateToJsonMethod(
        eventType: TypeName,
        fields: MutableList<VariableElement>,
        clazz: TypeElement,
        containSuperElement: Boolean,
    ): MethodSpec {
        val toJsonMethod = MethodSpec.methodBuilder("toJson")
            .addParameter(ClassName.get(JSON_OBJECT_PACKAGE, JSON_OBJECT_CLASS), "jsonObject")
            .addParameter(eventType, "event").addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override::class.java)

        if (containSuperElement) {
            val superElement = clazz.superclass
            val superClassName = superElement.toString().substringAfterLast(".")
            val superPackageName = superElement.toString().substringBeforeLast(".")
            val superName = superClassName + GENERATE_CLASS_APPEND
            val superClass = ClassName.get(superPackageName, superName)
            toJsonMethod.addStatement("\$T.create().toJson(jsonObject, event)", superClass)
        }

        if (fields.isNotEmpty()) {
            toJsonMethod.beginControlFlow("try")
            fields.forEach { field ->
                var fieldName = field.simpleName.toString()
                val jsonAliasAnnotation = field.getAnnotation(JsonAlias::class.java)
                if (jsonAliasAnnotation != null) {
                    val name = jsonAliasAnnotation.name
                    if (name.isNotEmpty()) fieldName = name
                }
                val fieldMethod = processUtils.findGetFieldMethod(field, clazz)
                if (fieldMethod == null) {
                    processUtils.debugLog("could not assign value to property.")
                    return@forEach
                }
                if (field.asType().kind == TypeKind.INT || field.asType().kind == TypeKind.LONG) {
                    val annotation = field.getAnnotation(IntRange::class.java)
                    if (annotation != null) {
                        val state = if (annotation.from == annotation.to) {
                            "if (event.$fieldMethod != ${annotation.from})"
                        } else {
                            val hasFrom =
                                if (annotation.from != Long.MIN_VALUE) "event.$fieldMethod > ${annotation.from}" else ""
                            val hasTo =
                                if (annotation.to != Long.MAX_VALUE) "event.$fieldMethod < ${annotation.to}" else ""
                            if (hasFrom.isNotEmpty() && hasTo.isNotEmpty()) {
                                "if ($hasFrom && $hasTo)"
                            } else if (hasFrom.isEmpty() && hasTo.isEmpty()) {
                                null
                            } else {
                                "if ($hasFrom$hasTo)"
                            }
                        }
                        if (state != null) {
                            toJsonMethod.beginControlFlow(state)
                                .addStatement("jsonObject.put(\"${fieldName}\", event.$fieldMethod)")
                                .endControlFlow()
                        } else {
                            toJsonMethod.addStatement("jsonObject.put(\"${fieldName}\", event.$fieldMethod)")
                        }
                    } else {
                        toJsonMethod.addStatement("jsonObject.put(\"${fieldName}\", event.$fieldMethod)")
                    }
                } else if (field.asType().kind == TypeKind.DOUBLE || field.asType().kind == TypeKind.FLOAT) {
                    val annotation = field.getAnnotation(FloatRange::class.java)
                    if (annotation != null) {
                        val state = if (annotation.from == annotation.to) {
                            "if (event.$fieldMethod != ${annotation.from})"
                        } else {
                            val fromEqual = if (annotation.fromInclusive) ">=" else ">"
                            val toEqual = if (annotation.toInclusive) "<=" else "<"
                            val hasFrom =
                                if (annotation.from != Double.NEGATIVE_INFINITY) "event.$fieldMethod $fromEqual ${annotation.from}" else ""
                            val hasTo =
                                if (annotation.to != Double.POSITIVE_INFINITY) "event.$fieldMethod $toEqual ${annotation.to}" else ""
                            if (hasFrom.isNotEmpty() && hasTo.isNotEmpty()) {
                                "if ($hasFrom && $hasTo)"
                            } else if (hasFrom.isEmpty() && hasTo.isEmpty()) {
                                null
                            } else {
                                "if ($hasFrom$hasTo)"
                            }
                        }
                        if (state != null) {
                            toJsonMethod.beginControlFlow(state)
                                .addStatement("jsonObject.put(\"${fieldName}\", event.$fieldMethod)")
                                .endControlFlow()
                        } else {
                            toJsonMethod.addStatement("jsonObject.put(\"${fieldName}\", event.$fieldMethod)")
                        }
                    } else {
                        toJsonMethod.addStatement("jsonObject.put(\"${fieldName}\", event.$fieldMethod)")
                    }
                } else if ("java.lang.String" == field.asType().toString()) {
                    val annotation = field.getAnnotation(Nullable::class.java)
                    if (annotation != null) {
                        toJsonMethod.beginControlFlow(
                            "if(!\$T.isEmpty(event.$fieldMethod))",
                            ClassName.get(TEXT_UTILS_PACKAGE, TEXT_UTILS_CLASS),
                        )
                            .addStatement("jsonObject.put(\"${fieldName}\", event.$fieldMethod)")
                            .endControlFlow()
                    } else {
                        toJsonMethod.addStatement("jsonObject.put(\"${fieldName}\", event.$fieldMethod)")
                    }
                } else if ("java.util.Map<java.lang.String,java.lang.String>" == field.asType()
                        .toString()
                ) {
                    val annotation = field.getAnnotation(Nullable::class.java)
                    if (annotation != null) {
                        toJsonMethod.addStatement(
                            "\$T $fieldName = event.$fieldMethod;",
                            ParameterizedTypeName.get(
                                ClassName.get(Map::class.java),
                                ClassName.get(String::class.java),
                                ClassName.get(String::class.java),
                            )
                        )
                        toJsonMethod.beginControlFlow("if($fieldName != null && !$fieldName.isEmpty())")
                            .addStatement("$fieldName.remove(null)")
                            .addStatement(
                                "jsonObject.put(\"${fieldName}\", new \$T(event.$fieldMethod))",
                                ClassName.get(JSON_OBJECT_PACKAGE, JSON_OBJECT_CLASS),
                            ).endControlFlow()
                    } else {
                        toJsonMethod.addStatement(
                            "jsonObject.put(\"${fieldName}\", new \$T(event.$fieldMethod))",
                            ClassName.get(JSON_OBJECT_PACKAGE, JSON_OBJECT_CLASS),
                        )
                    }
                } else {
                    toJsonMethod.addStatement("jsonObject.put(\"${fieldName}\", event.$fieldMethod)")
                }
            }

            toJsonMethod.nextControlFlow(
                "catch (\$T ignored)",
                ClassName.get(JSON_OBJECT_PACKAGE, JSON_OBJECT_EXCEPTION),
            ).endControlFlow()
        }

        return toJsonMethod.build()
    }

    /**
     * @Override
     * public void parseFrom(BaseEvent.BaseBuilder<BaseEvent> builder, JSONObject json) {}
     */
    private fun generateParseFromMethod(
        parameterizedBuilderType: TypeName,
        builderName: String,
        fields: MutableList<VariableElement>,
        clazz: TypeElement,
        containSuperElement: Boolean,
    ): MethodSpec {
        val parseFromMethod =
            MethodSpec.methodBuilder("parseFrom").addParameter(parameterizedBuilderType, "builder")
                .addParameter(ClassName.get(JSON_OBJECT_PACKAGE, JSON_OBJECT_CLASS), "jsonObject")
                .addModifiers(Modifier.PUBLIC).addAnnotation(Override::class.java)

        if (containSuperElement) {
            // BaseEventJsonSerializableFactory.create().parseFrom(builder, jsonObject);
            val superElement = clazz.superclass
            val superClassName = superElement.toString().substringAfterLast(".")
            val superPackageName = superElement.toString().substringBeforeLast(".")
            val superName = superClassName + GENERATE_CLASS_APPEND
            val superClass = ClassName.get(superPackageName, superName)
            parseFromMethod.addStatement("\$T.create().parseFrom(builder, jsonObject)", superClass)
        }

        if (fields.isNotEmpty()) {
            parseFromMethod.beginControlFlow("try")
            val builderTypeElement =
                processEnv.elementUtils.getTypeElement(clazz.qualifiedName.toString() + "." + builderName)

            fields.forEach { field ->
                var fieldName = field.simpleName.toString()
                val jsonAliasAnnotation = field.getAnnotation(JsonAlias::class.java)
                if (jsonAliasAnnotation != null) {
                    val name = jsonAliasAnnotation.name
                    if (name.isNotEmpty()) fieldName = name
                }
                val fieldMethod = processUtils.findSetFieldMethod(field, builderTypeElement)
                if (fieldMethod == null) {
                    processUtils.debugLog("could not assign value to property.")
                    return@forEach
                }
                if (field.asType().kind == TypeKind.INT) {
                    parseFromMethod.addStatement(
                        "builder.$fieldMethod".replace(
                            FIELD_REPLACE_REG,
                            "jsonObject.optInt(\"$fieldName\")",
                        ),
                    )
                } else if (field.asType().kind == TypeKind.LONG) {
                    parseFromMethod.addStatement(
                        "builder.$fieldMethod".replace(
                            FIELD_REPLACE_REG,
                            "jsonObject.optLong(\"$fieldName\")",
                        ),
                    )
                } else if (field.asType().kind == TypeKind.FLOAT) {
                    parseFromMethod.addStatement(
                        "builder.$fieldMethod".replace(
                            FIELD_REPLACE_REG,
                            "jsonObject.optDouble(\"$fieldName\", 0)",
                        ),
                    )
                } else if (field.asType().kind == TypeKind.DOUBLE) {
                    parseFromMethod.addStatement(
                        "builder.$fieldMethod".replace(
                            FIELD_REPLACE_REG,
                            "jsonObject.optDouble(\"$fieldName\", 0.0)",
                        ),
                    )
                } else if (field.asType().kind == TypeKind.BOOLEAN) {
                    parseFromMethod.addStatement(
                        "builder.$fieldMethod".replace(
                            FIELD_REPLACE_REG,
                            "jsonObject.optBoolean(\"$fieldName\")",
                        ),
                    )
                } else if ("java.lang.String" == field.asType().toString()) {
                    parseFromMethod.addStatement(
                        "builder.$fieldMethod".replace(
                            FIELD_REPLACE_REG,
                            "jsonObject.optString(\"$fieldName\")",
                        ),
                    )
                } else if ("java.util.Map<java.lang.String,java.lang.String>" == field.asType()
                        .toString()
                ) {
                    parseFromMethod.addStatement(
                        "\$T json = jsonObject.optJSONObject(\"$fieldName\")",
                        ClassName.get(JSON_OBJECT_PACKAGE, JSON_OBJECT_CLASS),
                    )
                    parseFromMethod.addStatement(
                        "if(json == null) return"
                    )
                    parseFromMethod.addStatement(
                        "\$T map = new \$T()",
                        ParameterizedTypeName.get(
                            ClassName.get(Map::class.java),
                            ClassName.get(String::class.java),
                            ClassName.get(String::class.java),
                        ),
                        ParameterizedTypeName.get(
                            ClassName.get(HashMap::class.java),
                            ClassName.get(String::class.java),
                            ClassName.get(String::class.java),
                        ),
                    )
                    parseFromMethod.addStatement(
                        "\$T keys = json.keys()",
                        ParameterizedTypeName.get(
                            ClassName.get(Iterator::class.java),
                            ClassName.get(String::class.java),
                        ),
                    )
                    parseFromMethod.beginControlFlow("while (keys.hasNext())")
                    parseFromMethod.addStatement("\$T key = keys.next()", String::class.java)
                    parseFromMethod.addStatement("map.put(key, json.getString(key))")
                    parseFromMethod.endControlFlow()
                    parseFromMethod.addStatement(
                        "builder.$fieldMethod".replace(
                            FIELD_REPLACE_REG,
                            "map",
                        ),
                    )
                } else {
                    processUtils.debugLog("unsupported data type.")
                }
            }

            parseFromMethod.nextControlFlow(
                "catch (\$T ignored)",
                Exception::class.java,
            ).endControlFlow()
        }

        return parseFromMethod.build()
    }
}
