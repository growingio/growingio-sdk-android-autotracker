package com.growingio.sdk.annotation.compiler;

import com.growingio.sdk.annotation.GIOModule;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.TypeSpec;

import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;

/**
 * Generates an empty class with an annotation containing the class names of one or more
 * LibraryGioModules.
 *
 *
 * <p>The output file generated by this class with a LibraryModule looks like this:
 *
 * <pre>
 * <code>
 *     {@literal @Index(}
 *       modules = "com.cpacm.module.module.TestModule"
 *   )
 *   public class GioIndexer_GIOModule_com_xxx_xxxModule {
 *   }
 * </code>
 * </pre>
 */
final class IndexerGenerator {
    private static final String INDEXER_NAME_PREFIX = "GioIndexer_";
    private static final int MAXIMUM_FILE_NAME_LENGTH = 255;
    private final ProcessUtils processUtils;

    IndexerGenerator(ProcessUtils processUtils) {
        this.processUtils = processUtils;
    }

    void generate(List<TypeElement> types) {
        List<TypeElement> modules = new ArrayList<>();
        for (TypeElement element : types) {
            if (processUtils.isAppGioModule(element)) {
                continue;
            }
            if (processUtils.isGioModule(element)) {
                modules.add(element);
            } else {
                throw new IllegalArgumentException("Unrecognized type: " + element);
            }
        }
        processUtils.debugLog("generate indexer:" + types);

        if (modules.size() > 0) {
            TypeSpec indexer = generate(modules, GIOModule.class);
            processUtils.writeIndexer(indexer);
            processUtils.debugLog("[" + processUtils.getRound() + "]" +
                    "Wrote an Indexer this round, skipping the app module to ensure all "
                    + "indexers are found");
        }
    }

    private TypeSpec generate(
            List<TypeElement> libraryModules, Class<? extends Annotation> annotation) {

        AnnotationSpec.Builder annotationBuilder = AnnotationSpec.builder(Index.class);

        String value = getAnnotationValue(annotation);
        for (TypeElement childModule : libraryModules) {
            annotationBuilder.addMember(value, "$S", ClassName.get(childModule).toString());
        }

        StringBuilder indexerNameBuilder =
                new StringBuilder(INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_");
        for (TypeElement element : libraryModules) {
            indexerNameBuilder.append(element.getQualifiedName().toString().replace(".", "_"));
            indexerNameBuilder.append("_");
        }
        indexerNameBuilder =
                new StringBuilder(indexerNameBuilder.substring(0, indexerNameBuilder.length() - 1));
        String indexerName = indexerNameBuilder.toString();
        // If the indexer name has too many packages/modules, it can exceed the file name length
        // allowed by the file system, which can break compilation. To avoid that, fall back to a
        // deterministic UUID.
        if (indexerName.length() >= (MAXIMUM_FILE_NAME_LENGTH - INDEXER_NAME_PREFIX.length())) {
            indexerName =
                    INDEXER_NAME_PREFIX
                            + UUID.nameUUIDFromBytes(indexerName.getBytes()).toString().replace("-", "_");
        }

        return TypeSpec.classBuilder(indexerName)
                .addAnnotation(annotationBuilder.build())
                .addModifiers(Modifier.PUBLIC)
                .build();
    }

    private static String getAnnotationValue(Class<? extends Annotation> annotation) {
        if (annotation == GIOModule.class) {
            return "modules";
        } else {
            throw new IllegalArgumentException("Unrecognized annotation: " + annotation);
        }
    }
}
