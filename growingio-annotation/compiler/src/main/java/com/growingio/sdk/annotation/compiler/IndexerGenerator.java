/*
 * Copyright (C) 2023 Beijing Yishu Technology Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.growingio.sdk.annotation.compiler;

import com.growingio.sdk.annotation.GIOLibraryModule;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.TypeSpec;

import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.AnnotationValue;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;

import static com.growingio.sdk.annotation.compiler.ProcessUtils.GIO_INDEX_ANNOTATION_CONFIGS;
import static com.growingio.sdk.annotation.compiler.ProcessUtils.GIO_INDEX_ANNOTATION_MODULES;

/**
 * Generates an empty class with an annotation containing the class names of one or more
 * LibraryGioModules.
 *
 *
 * <p>The output file generated by this class with a LibraryModule looks like this:
 *
 * <pre>
 * <code>
 *     {@literal @Index(}
 *       modules = "com.cpacm.module.module.TestModule"
 *       configs = "com.cpacm.module.module.Config"
 *   )
 *   public class GioIndexer_GIOModule_com_xxx_xxxModule {
 *   }
 * </code>
 * </pre>
 */
final class IndexerGenerator {
    private static final String INDEXER_NAME_PREFIX = "GioIndexer_";
    private static final int MAXIMUM_FILE_NAME_LENGTH = 255;
    private final ProcessUtils processUtils;

    IndexerGenerator(ProcessUtils processUtils) {
        this.processUtils = processUtils;
    }

    void generate(List<TypeElement> types) {
        List<TypeElement> modules = new ArrayList<>();
        for (TypeElement element : types) {
            if (processUtils.isAppGioModule(element)) {
                throw new IllegalArgumentException("[" + processUtils.getRound() + "]" +
                        "You can't use @GIOLibraryModule with AppGioModule");
            }
            if (processUtils.isGioModule(element)) {
                modules.add(element);
            } else {
                throw new IllegalArgumentException("Unrecognized type: " + element + "You should use @GIOLibraryModule with LibraryGioModule");
            }
        }
        processUtils.debugLog("generate indexer:" + types);

        if (modules.size() > 0) {
            TypeSpec indexer = generate(modules, GIOLibraryModule.class);
            processUtils.writeIndexer(indexer);
            processUtils.debugLog("[" + processUtils.getRound() + "]" +
                    "Wrote an Indexer this round, skipping the app module to ensure all "
                    + "indexers are found");
        }
    }

    private TypeSpec generate(List<TypeElement> libraryModules, Class<? extends Annotation> annotation) {

        AnnotationSpec.Builder annotationBuilder = AnnotationSpec.builder(Index.class);

        // add module
        for (TypeElement childModule : libraryModules) {
            annotationBuilder.addMember(GIO_INDEX_ANNOTATION_MODULES, "$S", ClassName.get(childModule).toString());
        }
        // add config
        String annotationClassName = GIOLibraryModule.class.getName();
        for (TypeElement childModule : libraryModules) {
            for (AnnotationMirror annotationMirror : childModule.getAnnotationMirrors()) {
                if (!annotationClassName.equals(annotationMirror.getAnnotationType().toString())) {
                    continue;
                }
                for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationMirror.getElementValues().entrySet()) {
                    //String key = entry.getKey().getSimpleName().toString();//judge isEqual 'config'
                    //Type.ClassType classType = (Type.ClassType) entry.getValue().getValue();
                    //processUtils.debugLog("classType: " + classType.tsym.getQualifiedName().toString());
                    String mirrorValue = entry.getValue().getValue().toString();
                    if (!mirrorValue.equals(Void.class.getName())) {
                        annotationBuilder.addMember(GIO_INDEX_ANNOTATION_CONFIGS, "$S", mirrorValue);
                    }

                    processUtils.debugLog(entry.getKey().getSimpleName() + ":" + entry.getValue().getValue());
                }
            }
        }

        StringBuilder indexerNameBuilder =
                new StringBuilder(INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_");
        for (TypeElement element : libraryModules) {
            indexerNameBuilder.append(element.getQualifiedName().toString().replace(".", "_"));
            indexerNameBuilder.append("_");
        }
        indexerNameBuilder =
                new StringBuilder(indexerNameBuilder.substring(0, indexerNameBuilder.length() - 1));
        String indexerName = indexerNameBuilder.toString();
        // If the indexer name has too many packages/modules, it can exceed the file name length
        // allowed by the file system, which can break compilation. To avoid that, fall back to a
        // deterministic UUID.
        if (indexerName.length() >= (MAXIMUM_FILE_NAME_LENGTH - INDEXER_NAME_PREFIX.length())) {
            indexerName =
                    INDEXER_NAME_PREFIX
                            + UUID.nameUUIDFromBytes(indexerName.getBytes()).toString().replace("-", "_");
        }

        return TypeSpec.classBuilder(indexerName)
                .addAnnotation(annotationBuilder.build())
                .addModifiers(Modifier.PUBLIC)
                .build();
    }

//    private static String getAnnotationValue(Class<? extends Annotation> annotation) {
//        if (annotation == GIOLibraryModule.class) {
//            return "modules";
//        } else {
//            throw new IllegalArgumentException("Unrecognized annotation: " + annotation);
//        }
//    }
}
